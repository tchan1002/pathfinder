// ---------- Generators & datasource ----------

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Add connection pooling and timeout settings
  relationMode = "prisma"
}

// ---------- Models ----------

model Site {
  id        String   @id @default(uuid()) @db.Uuid
  domain    String   @unique
  startUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pages Page[]
}

model Page {
  id             String    @id @default(uuid()) @db.Uuid
  siteId         String    @db.Uuid
  url            String
  urlNormalized  String
  title          String?
  metaDescription String?
  content        String?   @db.Text
  contentHash    String?
  lastCrawledAt  DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  site       Site       @relation(fields: [siteId], references: [id], onDelete: Cascade)
  summaries  Summary[]
  snapshots  Snapshot[]
  embeddings Embedding[]

  @@unique([siteId, urlNormalized])
  @@index([siteId])
}

model Summary {
  id        String   @id @default(uuid()) @db.Uuid
  pageId    String   @db.Uuid
  text      String   @db.Text
  textHash  String
  model     String
  createdAt DateTime @default(now())

  page Page @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@unique([pageId, textHash])
  @@index([pageId])
}

model Snapshot {
  id             String   @id @default(uuid()) @db.Uuid
  pageId         String   @db.Uuid
  screenshotPath String
  createdAt      DateTime @default(now())

  page Page @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@index([pageId])
}

// Note: We store embeddings in a dedicated table with a pgvector column.
// Prisma will map the vector type as Unsupported("vector"). Ensure the
// `vector` extension is installed before migrating (seed script does this).
model Embedding {
  id        String   @id @default(uuid()) @db.Uuid
  pageId    String   @db.Uuid
  content   String   @db.Text
  vector    Unsupported("vector")
  model     String
  createdAt DateTime @default(now())

  page Page @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@index([pageId])
  @@map("Embedding")
}

// ---------- Sherpa API Models ----------

model CrawlJob {
  id          String    @id @default(uuid()) @db.Uuid
  startUrl    String
  domain      String
  status      String    // "queued" | "running" | "done" | "error"
  startedAt   DateTime? @map("started_at")
  finishedAt  DateTime? @map("finished_at")
  userId      String?   @map("user_id")
  maxPages    Int?      @map("max_pages")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  pageScores PageScore[]
  feedback   Feedback[]

  @@index([domain, startedAt(sort: Desc)])
  @@index([status, startedAt(sort: Desc)])
  @@map("CrawlJob")
}

model PageScore {
  id           BigInt   @id @default(autoincrement())
  jobId        String   @map("job_id") @db.Uuid
  url          String
  title        String
  score        Float
  rank         Int
  signalsJson  Json?    @map("signals_json")
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at")

  job CrawlJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId, rank])
  @@index([jobId, score(sort: Desc)])
  @@index([url])
  @@map("PageScore")
}

model Feedback {
  id           BigInt   @id @default(autoincrement())
  jobId        String   @map("job_id") @db.Uuid
  landedUrl    String   @map("landed_url")
  wasCorrect   Boolean  @map("was_correct")
  chosenRank   Int?     @map("chosen_rank")
  userId       String?  @map("user_id")
  createdAt    DateTime @default(now()) @map("created_at")

  job CrawlJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([userId, createdAt(sort: Desc)])
  @@map("Feedback")
}

model UserPref {
  userId        String   @id @map("user_id")
  keywords      String[]
  autoRedirect  Boolean  @default(true) @map("auto_redirect")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  @@map("UserPref")
}
